# -*- coding: utf-8 -*-
"""DataStructure-Algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NKW__nLGkGVWgZTcnmtW5aQPDNWwhCCE
"""

number_first = 10
number_second = 20
result = number_first + number_second
result
# Time Complexity: O(1)
# Space Complexity: O(1)

n = input()
n = int(n)
result = n * (n+1) / 2
result

# Time Complexity: O(1)
# Space Complexity: O(1)

n = input()
n = int(n)
result = 0
for i in range(1, n+1):
  result = result + i
result

# Time Complexity: O(n)
# Space Complxity: O(n)

n = input()
n = int(n)

if n%2 == 0:
  print(n, "is even number")
else:
  print(n, "is odd number")

# Time Complexity: O(1)
# Space Complexity: O(1)

n = 100
even = [False] * (n+1)
for i in range (0, n+1, 2):
    even[i] = True

#even[2]
#even[3]
#even[99]
even[100]

# Time Complexity: O(n)
# Space Complexity: O(n)

n = input()
n = int(n)

count = 0

for i in range(n):
    for j in range(n):
        count +=1

print("n =", n, "count =", count)

# Time Complexity: O(n^2)

n = input()
n = int(n)

count = 0

for i in range(n):
    count += 1

print("n =", n, "count =", count)

# Time Complexity: O(n)
# Space Complexity: O(n)

n = input()
n = int(n)

count = 0

for i in range(n):
    for j in range(n):
        for k in range(n):
            count +=1

print("n =", n, "count =", count)

# Time Complexity: O(n^3)
# Space Complexity: O(n^3)

n = input()
n = int(n)

count = 0

for i in range(n):
    count +=1

for i in range(n):
    for j in range(n):
        count += 1

print(count)

# Time Complexity: O(n^2)
# Space Complexity: O(n^2)

"""# Chapter 3: Unit Test """

def average(L):
    if not L:
        return None

    return sum(L)/len(L)

if __name__ == "__main__":
    L = [1, 2, 3, 4, 5]
    print(average(L))

def average(L):
    if not L:
        return None

    return sum(L)/len(L)

if __name__ == "__main__":
    L = [1, 2, 3, 4, 5]
    expected_result = 3.0
    result = average(L)

    if expected_result == result:
        print("test passed")
    else: 
        print("test failed!", "received:", result, "expected:", expected_result)

assert 2 == 2

assert 2 == 3

assert 2 == 2.0

li = []

assert li == []

assert li == [1]

s = "123"
assert s == "123"

assert s == 123

assert 3 > 2, "of course 3 is greater than 2"
assert 3 < 2, "how can 3 be less than 2?"

if __name__ == "__main__":
    L = [1, 2, 3, 4, 5]
    expected_result = 3.0
    assert expected_result == average(L), "average() produced incorrect result"

def average(L):
    if not L:
        return None
    
    return sum(L)/len(L)

def test_average():
    assert 3.0 == average([1, 2, 3, 4, 5])

pip -q install pytest pytest-sugar

def test_average():
    test_cases = [
        {
            "name": "simple case 1",
            "input": [1, 2, 3], 
            "expected": 2.0
        },
        {
            "name": "simple case 2",
            "input": [1, 2, 3, 4],
            "expected": 2.5
        },
        {
            "name": "simple case 3",
            "input": [100],
            "expected": 100.0
        },
        {
            "name": "empty list",
            "input": [],
            "expected": None
        }
    ]

    for test_case in test_cases:
        assert test_case["expected"] == average(test_case["input"]), test_case["name"]

"""# Chapter 4: Searching Algorithm
## Linear Search
### Time Complexity: O(n)
### Space complexity: O(1)
"""

def linear_search(L, x):
    n = len(L)
    i = 0

    while i < n:
        if L[i] == x:
            return i

        i += 1 
    
    i = -1

    return i

def linear_search_2(L, x):
    n = len(L)
    for i in range(n):
        if L[i] == x:
            return i
    return -1

"""## Binary Search
### Time Complexity: O(log n)
### Space complexity: O(1)
"""

def binsary_search(L, x):
    left, right = 0, len(L) - 1

    while left <= right:
        mid = (left + right) // 2 # integer division

        if L[mid] == x:
            return mid
        if L[mid] < x:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

if __name__ == "__main__":
    L = [1, 2, 3, 4, 5, 6, 7, 8, 9]

    for x in range(1, 11):
        position = binary_search(L, x)
    
        if position == -1:

            if x in L:
                print(x, "is in L, but function returned - 1")

            else:
                print(x, "not in list")
        
        else:
            if L[position] == x:
                print(x, "found in correct position.")
            else:
                print("binary search returned", position, "for", x, "which is incorrect")
    print("program terminated")

"""# Chapter 5: Sorting Algorithm
## Selection Sort
### Time Complexity: O(n^2)
### Space complexity: O(1)
"""

def selection_sort(L):
    n = len(L)

    for i in range(0, n-1):
        index_min = i

        for j in range(i+1, n):
            if L[j] < L[index_min]:
                index_min = j
        
        if index_min != i:
            L[i], L[index_min] = L[index_min], L[i]

if __name__ == "__main__":
    L = [6, 1, 4, 9, 2]
    print("Before sort:", L)
    selection_sort(L)
    print("After sort:", L)

"""## Bubble Sort
### Time Complexity: O(n^2)
### Space complexity: O(1)
"""

def bubble_sort(L):
    n = len(L)

    for i in range(0, n):
        for j in range(0, n-i-1):
            if L[j] > L[j+1]:
                L[j], L[j+1] = L[j+1], L[j]

if __name__ == "__main__":
    L = [6, 1, 4, 9, 2]
    print("Before sort:", L)
    bubble_sort(L)
    print("After sort:", L)

def bubble_sort(L):
    n = len(L)

    for i in range(0, n):
        for j in range(0, n-i-1):
            if L[j] > L[j+1]:
                L[j], L[j+1] = L[j+1], L[j]
                print(L)

if __name__ == "__main__":
    L = [6, 1, 4, 9, 2]
    print("Before sort:", L)
    bubble_sort(L)
    print("After sort:", L)

"""## Insertion Sort
### Time Complexity: O(n^2)
### Space complexity: O(1)
"""

def insertion_sort(L):
    n = len(L)

    for i in range(1, n):
        item = L[i]

        j = i - 1

        while j >= 0 and L[j] > item:
            L[j+1] = L[j]
            j = j - 1
            L[j+1] = item

if __name__ == "__main__":
    L = [6, 1, 4, 9, 2]
    print("Before sort:", L)
    insertion_sort(L)
    print("After sort:", L)

"""# Chapter 6: Stack and Queue
## Stack
### Time Complexity: Push: O(1); Pop: O(1)
### Space complexity: 
"""

li = []

li.append(1)

li

li.append(2)

li

li.pop()

li.pop()

li

li.pop()

class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def is_empty(self):
        if self.items == []:
            return True
        return False

if __name__ == "__main__":
    s = Stack()
    s.push(1)
    s.push(2)
    s.push(3)

    while not s.is_empty():
        item = s.pop()
        print(item)

def is_balanced(input_str):
    s = list()

    for ch in input_str:
        if ch == '(':
            s.append(ch)
        if ch == ')':
            if not s:
                return False
            s.pop()
    
    return not s

if __name__ == "__main__":
    input_str = input()

    if is_balanced(input_str):
        print(input_str, "is balanced.")
    else:
        print(input_str, "is not balanced.")

"""## Queue
### Time Complexity: Push: O(1); Pop: O(n) in general but can be O(1)
### Space complexity: 
"""

li = [1, 2, 3, 4]

li.pop(0)

li

li.pop(0)

li





class Queue:
    def __init__(self):
        self.items = []
    
    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        return self.items.pop(0)

    def is_empty(self):
        if self.items == []:
            return True
        return False

if __name__ == "__main__":
    q = Queue()
    q.enqueue("Aminul")
    q.enqueue("Islam")
    q.enqueue("Shihab")

    while not q.is_empty():
        person = q.dequeue()
        print(person)

class Queue:

    def __init__(self, size):
        self.items = [0] * size
        self.max_size = size
        self.head, self.tail, self.size = 0, 0, 0
    
    def enqueue(self, item):
        if self.is_full():
            print("Queue is full!")

            return 

        print("Inserting", item)
        self.items[self.tail] = item
        self.tail = (self.tail + 1) % self.max_size
        self.size += 1

    def dequeue(self):
        item = self.items[self.head]
        self.head = (self.head + 1) % self.max_size
        self.size -=1

        return item

    def is_empty(self):
        if self.size == 0:
            return True

        return False

    def is_full(self):
        if self.size == self.max_size:
            return True

        return False


if __name__ == "__main__":
    q = Queue(2)
    q.enqueue("Aminul")
    q.enqueue("Islam")
    q.enqueue("Shihab")

    while not q.is_empty():
        person = q.dequeue()
        print(person)

    q.enqueue("Shihab")
    print(q.items)
    print("head:", q.head)
    print("tail", q.tail)

"""# Chapter 7: Linked List
## Linked List
### Time Complexity: 
#### Adding/Removing element at first node: O(1)
#### Adding/Removing element at any node: O(n)
### Space complexity: 
"""

class Node:
    def __init__(self, data = None, next = None):
        self.data = data
        self.next = next

    def __repr__(self):
        return repr(self.data)

class LinkedList:
    def __init__(self):
        self.head = Node()

    def __repr__(self):
        nodes = []
        current_node = self.head.next

        while current_node:
            nodes.append(repr(current_node))
            current_node = current_node.next

        return ",".join(nodes)

    def append(self, data):
        pass
    
    def prepend(self, data):
        pass

    def insert(self, data, new_data):
        pass

    def search(self, item):
        pass

    def remove(self, item):
        pass

